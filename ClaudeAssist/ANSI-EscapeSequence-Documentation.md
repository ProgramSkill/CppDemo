# ANSI 转义序列处理与 OSC 序列修复

本文档说明 ConPTY 终端中 ANSI 转义序列的处理机制，以及 OSC 序列显示问题的修复方案。

## 目录

1. [问题现象](#问题现象)
2. [ANSI 转义序列概述](#ansi-转义序列概述)
3. [OSC 序列详解](#osc-序列详解)
4. [修复方案](#修复方案)
5. [代码实现](#代码实现)

---

## 问题现象

终端输出中出现类似以下的乱码：

```
Microsoft Windows [版本 10.0.26200.7623]]0;C:\Windows\SYSTEM32\cmd.exe
```

其中 `]0;C:\Windows\SYSTEM32\cmd.exe` 不应该显示在屏幕上。

---

## ANSI 转义序列概述

ANSI 转义序列是一种用于控制终端显示的特殊字符序列，以 `ESC` (0x1B) 开头。

### 常见序列类型

| 类型 | 格式 | 用途 |
|------|------|------|
| **CSI** | `ESC [` | 控制序列引导符，用于光标移动、颜色设置等 |
| **OSC** | `ESC ]` | 操作系统命令，用于设置窗口标题等 |
| **字符集** | `ESC (`, `ESC )` | 选择字符集 |
| **模式** | `ESC =`, `ESC >` | 键盘模式切换 |

### CSI 序列示例

```
ESC [ 2 J      - 清屏
ESC [ 1 ; 1 H  - 移动光标到 (1,1)
ESC [ 31 m     - 设置前景色为红色
ESC [ 0 m      - 重置所有属性
```

---

## OSC 序列详解

### 格式

```
ESC ] Ps ; Pt BEL
或
ESC ] Ps ; Pt ESC \
```

- `ESC ]` - OSC 序列开始标记
- `Ps` - 参数（数字）
- `;` - 分隔符
- `Pt` - 文本参数
- `BEL` (0x07) 或 `ESC \` - 序列结束标记

### 常用 OSC 命令

| Ps | 功能 |
|----|------|
| 0 | 设置窗口标题和图标名称 |
| 1 | 设置图标名称 |
| 2 | 设置窗口标题 |
| 4 | 设置/查询颜色 |
| 52 | 操作剪贴板 |

### 问题序列分析

```
ESC ] 0 ; C:\Windows\SYSTEM32\cmd.exe BEL
│   │ │ └─────────────────────────────┴── 窗口标题文本
│   │ └─ 分隔符
│   └─── 参数 0 = 设置窗口标题和图标
└─────── OSC 序列开始
```

当 `ESC` (0x1B) 被忽略时，剩余的 `]0;C:\Windows\...` 就会显示在屏幕上。

---

## 修复方案

### 修复前的代码逻辑

```csharp
// 只处理 CSI 序列
if (text[i] == '\x1b' && i + 1 < text.Length && text[i + 1] == '[')
{
    // 处理 CSI 序列...
}
```

**问题**：只检测 `ESC [` (CSI)，忽略了 `ESC ]` (OSC) 等其他序列。

### 修复后的代码逻辑

```csharp
if (text[i] == '\x1b' && i + 1 < text.Length)
{
    char nextChar = text[i + 1];

    if (nextChar == '[')
    {
        // 处理 CSI 序列...
    }
    else if (nextChar == ']')
    {
        // 处理 OSC 序列 - 查找结束符并跳过
    }
    else if (nextChar == '(' || nextChar == ')' || ...)
    {
        // 处理其他转义序列...
    }
}
```

---

## 代码实现

### OSC 序列处理

```csharp
else if (nextChar == ']')
{
    // OSC 序列 (ESC ]) - 用于设置窗口标题等
    // 格式: ESC ] Ps ; Pt BEL 或 ESC ] Ps ; Pt ESC \
    int start = i + 2;
    int end = start;

    // 查找序列结束符 (BEL=0x07 或 ESC \)
    while (end < text.Length)
    {
        if (text[end] == '\x07') // BEL 字符
        {
            break;
        }
        if (text[end] == '\x1b' && end + 1 < text.Length && text[end + 1] == '\\')
        {
            end++; // 跳过 ESC \
            break;
        }
        end++;
    }

    // 跳过整个 OSC 序列（不显示）
    i = end + 1;
    continue;
}
```

### 其他转义序列处理

```csharp
// 字符集选择序列 (ESC ( B, ESC ) 0 等)
else if (nextChar == '(' || nextChar == ')' || nextChar == '*' || nextChar == '+')
{
    i += 3; // 跳过 ESC + 类型 + 字符集标识
    continue;
}

// 键盘模式序列 (ESC =, ESC >)
else if (nextChar == '=' || nextChar == '>')
{
    i += 2; // 跳过 ESC + 模式字符
    continue;
}
```

---

## 转义序列处理流程图

```
输入字符
    │
    ▼
是 ESC (0x1B)?
    │
    ├─ 否 ──► 普通字符处理（显示/控制字符）
    │
    └─ 是 ──► 检查下一个字符
                │
                ├─ '[' ──► CSI 序列
                │           └─ 查找命令字符，执行命令
                │
                ├─ ']' ──► OSC 序列
                │           └─ 查找 BEL 或 ESC \，跳过整个序列
                │
                ├─ '(' ')' '*' '+' ──► 字符集序列
                │                       └─ 跳过 3 个字符
                │
                └─ '=' '>' ──► 模式序列
                                └─ 跳过 2 个字符
```

---

## 支持的转义序列汇总

### CSI 序列 (ESC [)

| 序列 | 功能 |
|------|------|
| `ESC [ H` / `ESC [ f` | 光标定位 |
| `ESC [ A` | 光标上移 |
| `ESC [ B` | 光标下移 |
| `ESC [ C` | 光标右移 |
| `ESC [ D` | 光标左移 |
| `ESC [ J` | 清屏 |
| `ESC [ K` | 清行 |
| `ESC [ m` | SGR (颜色/样式) |

### OSC 序列 (ESC ])

| 序列 | 处理方式 |
|------|----------|
| `ESC ] 0 ; title BEL` | 跳过（不显示） |
| `ESC ] 1 ; title BEL` | 跳过（不显示） |
| `ESC ] 2 ; title BEL` | 跳过（不显示） |

### 其他序列

| 序列 | 处理方式 |
|------|----------|
| `ESC ( X` | 跳过 |
| `ESC ) X` | 跳过 |
| `ESC =` | 跳过 |
| `ESC >` | 跳过 |

---

## 总结

1. **问题根因**：OSC 序列 (`ESC ]`) 未被正确识别和过滤
2. **修复方法**：在转义序列处理中添加 OSC 序列检测，查找结束符 (BEL 或 ESC \) 并跳过整个序列
3. **扩展处理**：同时添加了字符集选择和键盘模式等其他转义序列的处理
