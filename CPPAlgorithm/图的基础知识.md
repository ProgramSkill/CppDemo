# 图的基础知识

## 目录

1. [什么是图](#什么是图)
2. [图的基本组成](#图的基本组成)
3. [图的基本术语](#图的基本术语)
4. [图的类型](#图的类型)
5. [图的表示方法](#图的表示方法)
6. [图的应用](#图的应用)
7. [常见算法](#常见算法)

---

## 什么是图

### 定义

**图**（Graph）是一种非线性数据结构，由**顶点**（Vertex）的集合和**边**（Edge）的集合组成。

### 通俗理解

图就像是**社交网络**：
- **顶点** = 人（用户）
- **边** = 人与人之间的关系（好友关系）

```
现实生活中的例子：

社交网络图
         ┌─────────────────────────────────────┐
         │   🌐 Social Network Graph           │
         └─────────────────────────────────────┘

              👤 Alice ──── 👤 Bob
                │            │
                │            │
              👤 Charlie    👤 David
                │
                │
              👤 Eva

✓ 顶点：Alice, Bob, Charlie, David, Eva
✓ 边：Alice-Bob, Alice-Charlie, Bob-David, Charlie-Eva
```

### 数学定义

```
图 G = (V, E)

其中：
- V = {v₁, v₂, ..., vₙ} 是顶点的集合
- E = {(u, v) | u, v ∈ V} 是边的集合
```

---

## 图的基本组成

### 顶点（Vertex）

顶点是图中的基本单元，也称为**节点**（Node）。

```cpp
// 顶点示例
顶点 0, 顶点 1, 顶点 2, 顶点 3

在地图中：
- 顶点 = 城市
- 顶点 = 路口
- 顶点 = 地铁站
```

### 边（Edge）

边是连接两个顶点的线段，表示顶点之间的关系。

```cpp
// 边示例
(0, 1), (1, 2), (2, 3)

在地图中：
- 边 = 道路
- 边 = 航线
- 边 = 铁路线
```

### 可视化示例

```
简单图：

    0 ------- 1
    |         |
    |         |
    |         |
    2 ------- 3

顶点：{0, 1, 2, 3}
边：{(0,1), (0,2), (1,3), (2,3)}
```

---

## 图的基本术语

### 1. 顶点和边

| 术语 | 英文 | 说明 |
|------|------|------|
| 顶点 | Vertex | 图中的节点 |
| 边 | Edge | 连接顶点的线 |
| 端点 | Endpoint | 边连接的两个顶点 |

### 2. 度（Degree）

**度**是指与一个顶点相连的边的数量。

```
示例：
    0 ------- 1
    |         |
    |         |
    2 ------- 3

degree(0) = 2  (与 1 和 2 相连)
degree(1) = 2  (与 0 和 3 相连)
degree(2) = 2  (与 0 和 3 相连)
degree(3) = 2  (与 1 和 2 相连)
```

**有向图的度**：

| 类型 | 英文 | 说明 |
|------|------|------|
| 入度 | In-Degree | 指向该顶点的边数 |
| 出度 | Out-Degree | 从该顶点出发的边数 |

```
有向图：
    0 --> 1 --> 2
    ↑     ↓     ↓
    └----- 3 ---┘

顶点 1：
- 入度 = 2  (从 0 和 3 来)
- 出度 = 1  (指向 2)
```

### 3. 路径（Path）

路径是顶点的序列，其中相邻顶点之间有边相连。

```
路径示例：
    0 --- 1 --- 2
    |         |
    |         |
    3 ------- 4

从 0 到 4 的路径：
1) 0 → 1 → 2 → 4
2) 0 → 3 → 4
3) 0 → 1 → 2 → ... (不存在的路径)
```

**路径长度**：路径中边的数量

```
路径 0 → 1 → 2 → 4 的长度 = 3
路径 0 → 3 → 4 的长度 = 2
```

### 4. 环路（Cycle）

环路是起点和终点相同的路径。

```
有环路：
    0 --- 1
    |     |
    |     |
    2 --- 3

环路：0 → 1 → 3 → 2 → 0

无环路（树）：
    0
   / \
  1   2
 /
3
```

### 5. 连通性

| 术语 | 说明 |
|------|------|
| **连通图** | 任意两个顶点之间都有路径 |
| **非连通图** | 存在无法互相到达的顶点对 |
| **连通分量** | 极大连通子图 |

```
连通图：
    0 --- 1 --- 2
    |         |
    3 ------- 4
    所有顶点都能互相到达

非连通图：
    0 --- 1     2 --- 3
    顶点 0,1 和 2,3 之间无法到达
```

### 6. 权重（Weight）

权重是边上的数值，表示边的"代价"或"成本"。

```
带权图：
    0 --5-- 1 --3-- 2
    |       |
    7       4
    |       |
    3-------+

边的权重：5, 3, 7, 4

实际意义：
- 道路长度
- 旅行时间
- 通行费用
- 网络延迟
```

---

## 图的类型

### 1. 无向图（Undirected Graph）

边没有方向的图。

```
示例：
    A --- B
    |     |
    |     |
    C --- D

特点：
- 边 (A, B) 和 (B, A) 相同
- 邻接矩阵对称
- 用途：好友关系、道路网络
```

### 2. 有向图（Directed Graph / Digraph）

边有方向的图。

```
示例：
    A --> B --> C
    ↑     ↓     ↓
    └----- D ---┘

特点：
- 边 (A, B) 和 (B, A) 不同
- 邻接矩阵不一定对称
- 用途：关注关系、网页链接、工作流
```

### 3. 带权图（Weighted Graph）

边带有权重的图。

```
示例：
    A --5-- B --3-- C
    |       |
    7       4
    |       |
    D-------+

特点：
- 每条边有权重
- 用途：最短路径、最小生成树
```

### 4. 无权图（Unweighted Graph）

边不带权重的图（所有边权重相同）。

```
示例：
    A --- B --- C
    |     |
    D-----+

特点：
- 所有边权重相同（通常为 1）
- 用途：连通性判断、可达性分析
```

### 5. 简单图（Simple Graph）

没有自环和重边的图。

```
简单图：
    0 --- 1 --- 2
    |         |
    3 ------- 4

特点：
- 没有自环（顶点到自己的边）
- 没有重边（两个顶点之间最多一条边）
```

### 6. 多重图（Multigraph）

允许有重边的图。

```
多重图：
    0 === 1 === 2
    ||     ||
    3 -----+

特点：
- 允许两个顶点之间有多条边
- 用途：航班路线（多个航班）
```

### 7. 完全图（Complete Graph）

任意两个顶点之间都有边的图。

```
完全图 K4：
        0
      / | \
     /  |  \
    1---+---2
     \  |  /
      \ | /
        3

特点：
- n 个顶点的完全图有 n(n-1)/2 条边
- K4 有 6 条边
- 用途：理论分析
```

### 8. 二分图（Bipartite Graph）

顶点可以分为两个独立集合，边只在两个集合之间。

```
二分图：
    A组：  0 ----- 1 ----- 2
           |       |       |
           |       |       |
    B组：  3 ----- 4 ----- 5

特点：
- 顶点分为两组
- 边只连接不同组的顶点
- 用途：匹配问题、调度问题
```

### 9. 树（Tree）

连通且无环的无向图。

```
树：
        0
       /|\
      / | \
     1  2  3
    /|  |
   4 5  6

特点：
- n 个顶点，n-1 条边
- 任意两个顶点之间只有一条路径
- 用途：组织结构、文件系统
```

### 10. 有向无环图（DAG）

没有环路的有向图。

```
DAG：
    0 --> 1 --> 2
          |     |
          v     v
          3 --> 4

特点：
- 有向图
- 没有环路
- 用途：任务调度、依赖关系、版本控制
```

---

## 图的表示方法

### 1. 邻接矩阵（Adjacency Matrix）

使用 n×n 的二维数组表示图。

```
图：
    0 --- 1
    |     |
    2 --- 3

矩阵：
   0  1  2  3
0 [0, 1, 1, 0]
1 [1, 0, 0, 1]
2 [1, 0, 0, 1]
3 [0, 1, 1, 0]

优点：O(1) 查询边
缺点：O(V²) 空间
```

### 2. 邻接表（Adjacency List）

使用数组+链表表示图。

```
图：
    0 --- 1
    |     |
    2 --- 3

邻接表：
0 -> [1, 2]
1 -> [0, 3]
2 -> [0, 3]
3 -> [1, 2]

优点：O(V+E) 空间
缺点：O(degree) 查询边
```

---

## 图的应用

### 1. 社交网络

```
应用场景：
- 好友关系图
- 关注关系图
- 社区发现

例子：
微信好友、微博关注、LinkedIn 职业关系
```

### 2. 地图与导航

```
应用场景：
- 道路网络
- 最短路径
- 导航系统

例子：
高德地图、Google 地图
```

### 3. 网络与通信

```
应用场景：
- 网络拓扑
- 路由算法
- 带宽分配

例子：
互联网路由、通信网络
```

### 4. 交通系统

```
应用场景：
- 航线网络
- 地铁线路
- 公交路线

例子：
航班调度、地铁换乘
```

### 5. 推荐系统

```
应用场景：
- 用户-物品图
- 协同过滤
- 社交推荐

例子：
电商推荐、音乐推荐
```

### 6. 编译器

```
应用场景：
- 依赖关系图
- 任务调度
- 代码优化

例子：
Make 依赖、模块导入
```

### 7. 生物学

```
应用场景：
- 蛋白质相互作用
- 基因调控网络
- 食物链

例子：
生物网络分析
```

### 8. 游戏开发

```
应用场景：
- 地图寻路
- AI 决策
- 关卡设计

例子：
游戏中的 NPC 寻路
```

---

## 常见算法

### 1. 遍历算法

| 算法 | 全称 | 特点 |
|------|------|------|
| **BFS** | 广度优先搜索 | 层级遍历，找最短路径 |
| **DFS** | 深度优先搜索 | 深度探索，找路径 |

```cpp
// BFS 示例
void BFS(int start) {
    std::queue<int> q;
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        // 处理 u
        for (int v : adj[u]) {
            if (!visited[v]) {
                visited[v] = true;
                q.push(v);
            }
        }
    }
}
```

### 2. 最短路径算法

| 算法 | 适用图 | 时间复杂度 |
|------|--------|-----------|
| **BFS** | 无权图 | O(V + E) |
| **Dijkstra** | 非负权图 | O((V + E) log V) |
| **Bellman-Ford** | 允许负权 | O(VE) |
| **Floyd-Warshall** | 所有点对 | O(V³) |

```cpp
// Dijkstra 算法示例
void dijkstra(int start) {
    std::priority_queue<pair<int,int>> pq;
    pq.push({0, start});
    dist[start] = 0;

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();

        for (auto& edge : adj[u]) {
            int v = edge.first;
            int w = edge.second;
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
}
```

### 3. 最小生成树算法

| 算法 | 时间复杂度 | 特点 |
|------|-----------|------|
| **Prim** | O((V + E) log V) | 适合稠密图 |
| **Kruskal** | O(E log E) | 适合稀疏图 |

### 4. 其他重要算法

| 算法 | 用途 |
|------|------|
| **拓扑排序** | 任务调度、依赖关系 |
| **强连通分量** | 图的分解 |
| **二分图匹配** | 匹配问题 |
| **网络流** | 最大流问题 |
| **欧拉路径** | 一笔画问题 |
| **哈密顿路径** | 旅行商问题 |

---

## 图的基本操作

### 1. 添加顶点

```cpp
void addVertex() {
    adj.emplace_back();  // 添加新的空邻接表
    V++;
}
```

### 2. 添加边

```cpp
void addEdge(int u, int v) {
    adj[u].push_back(v);
    adj[v].push_back(u);  // 无向图
}
```

### 3. 删除边

```cpp
void removeEdge(int u, int v) {
    adj[u].erase(std::remove(adj[u].begin(), adj[u].end(), v), adj[u].end());
    adj[v].erase(std::remove(adj[v].begin(), adj[v].end(), u), adj[v].end());
}
```

### 4. 检查边是否存在

```cpp
bool hasEdge(int u, int v) {
    for (int neighbor : adj[u]) {
        if (neighbor == v) return true;
    }
    return false;
}
```

---

## 特殊的图

### 1. 稀疏图 vs 稠密图

| 类型 | 定义 | 边数 |
|------|------|------|
| 稀疏图 | E << V² | E < V²/10 |
| 稠密图 | E ≈ V² | E > V²/10 |

```
稀疏图：          稠密图：
0 --- 1          0 === 1
|                 |\ /|
2                 | X |
                  |/ \|
                  3 --- 4
```

### 2. 连通图

| 类型 | 定义 |
|------|------|
| 强连通图 | 有向图中，任意两个顶点可互相到达 |
| 弱连通图 | 有向图忽略方向后连通 |
| 连通图 | 无向图，任意顶点可达 |

### 3. 正则图

所有顶点的度都相同的图。

```
3-正则图（每个顶点度数为3）：
      0 --- 1
     /|\   /|\
    / | \ / | \
   4--+---+--2
    \ | / \ | /
     \|/   \|/
      3 --- 5
```

---

## 图的存储对比

### 选择建议

| 场景 | 推荐表示 |
|------|---------|
| 稀疏图 | 邻接表 |
| 稠密图 | 邻接矩阵 |
| 频繁查询边 | 邻接矩阵 |
| 频繁遍历邻接点 | 邻接表 |
| 大规模图 | 邻接表 |
| 小规模图 | 邻接矩阵 |

---

## 总结

### 核心概念

```
图 = 顶点 + 边
表示关系最自然的数据结构
```

### 记忆要点

1. **基本组成**：顶点（V）、边（E）
2. **主要类型**：有向/无向、带权/无权
3. **表示方法**：邻接矩阵 O(V²)、邻接表 O(V+E)
4. **核心算法**：BFS/DFS、最短路径、最小生成树
5. **典型应用**：社交网络、地图导航、网络路由

### 学习路径

```
1. 理解基本概念（顶点、边、度、路径）
2. 掌握图的表示（邻接矩阵、邻接表）
3. 学习遍历算法（BFS、DFS）
4. 学习最短路径（Dijkstra、Bellman-Ford）
5. 学习高级算法（最小生成树、网络流）
6. 实际应用练习
```

---

## 参考资料

- [图论 - 维基百科](https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA)
- [Introduction to Algorithms (CLRS)](https://en.wikipedia.org/wiki/Introduction_to_Algorithms)
- [GeeksforGeeks - Graph Data Structure](https://www.geeksforgeeks.org/graph-data-structure-and-its-representations/)
- [OI Wiki - 图论](https://oi-wiki.org/graph/)
