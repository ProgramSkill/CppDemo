# 递推 (Recurrence/Iteration) - 自底向上的算法思想

递推是一种通过已知条件逐步推导出未知结果的算法思想，与递归自顶向下分解问题相反，递推采用自底向上的方式构建解。

---

## 目录

1. [什么是递推](#1-什么是递推)
2. [递推 vs 递归](#2-递推-vs-递归)
3. [递推的基本思想](#3-递推的基本思想)
4. [递推的要素](#4-递推的要素)
5. [递推的常见类型](#5-递推的常见类型)
6. [经典递推问题详解](#6-经典递推问题详解)
7. [递推优化技巧](#7-递推优化技巧)
8. [递推的应用场景](#8-递推的应用场景)
9. [递推与动态规划](#9-递推与动态规划)
10. [常见陷阱与错误](#10-常见陷阱与错误)
11. [学习路线](#11-学习路线)

---

## 1. 什么是递推

### 定义

递推 = 通过已知的初始条件（边界条件），按照一定的递推关系式，逐步计算出后续结果。

```cpp
// 斐波那契数列的递推实现
int fibonacci(int n) {
    if (n <= 1) return n;

    int prev2 = 0, prev1 = 1;  // 初始条件
    int curr;

    for (int i = 2; i <= n; i++) {
        curr = prev1 + prev2;  // 递推关系：F(n) = F(n-1) + F(n-2)
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

### 生活中的递推

```
多米诺骨牌：推倒第一块，后续依次倒下
阶梯攀登：从第一阶开始，一阶一阶向上爬
传话游戏：从第一个人开始，依次传递到最后
储蓄增长：从初始本金开始，按利率逐年增长
```

### 数学中的递推

```
斐波那契：F(n) = F(n-1) + F(n-2)，F(0)=0, F(1)=1
阶乘：n! = (n-1)! × n，0! = 1
等差数列：a(n) = a(n-1) + d
等比数列：a(n) = a(n-1) × q
```

---

## 2. 递推 vs 递归

### 对比表

| 特性 | 递归 | 递推 |
|------|------|------|
| **思维方式** | 自顶向下 | 自底向上 |
| **问题分解** | 大问题 → 小问题 | 小问题 → 大问题 |
| **计算方向** | 从目标向边界反向推导 | 从边界向目标正向推导 |
| **内存使用** | 调用栈 O(n) | 通常 O(1) |
| **性能** | 函数调用开销 | 通常更快 |
| **栈溢出风险** | 深度递归可能溢出 | 无此风险 |
| **代码可读性** | 声明式，符合数学定义 | 命令式，更直观 |
| **适用场景** | 分治、回溯、树遍历 | 序列计算、DP、优化 |

### 执行过程对比

**问题：计算斐波那契数列 F(5)**

#### 递归方式（自顶向下）
```
                F(5)                          ← 从这里开始
               /    \
           F(4)      F(3)                     ← 分解为子问题
          /    \    /    \
      F(3)   F(2) F(2)  F(1)                 ← 继续分解
     /   \
  F(2)  F(1)                                ← 直到基本情况
  /   \
F(1)  F(0)                                   ← 开始返回

重复计算：F(3) 计算了 2 次，F(2) 计算了 3 次！
时间复杂度：O(2^n)
```

#### 递推方式（自底向上）
```
步骤1: F(0) = 0                           ← 已知初始条件
步骤2: F(1) = 1                           ← 已知初始条件
步骤3: F(2) = F(1) + F(0) = 1             ← 向上递推
步骤4: F(3) = F(2) + F(1) = 2             ← 向上递推
步骤5: F(4) = F(3) + F(2) = 3             ← 向上递推
步骤6: F(5) = F(4) + F(3) = 5             ← 得到结果

每个值只计算一次！
时间复杂度：O(n)
空间复杂度：O(1)（只需保存前两个值）
```

### 何时选择递归，何时选择递推

```
选择递归：
✓ 问题天然具有递归结构（树、图）
✓ 使用分治策略
✓ 需要回溯（全排列、组合）
✓ 代码可读性优先
✓ 记忆化递归可以避免重复计算

选择递推：
✓ 问题可以用递推公式表达
✓ 需要优化空间和时间效率
✓ 递归深度可能很大
✓ 线性或简单的递推关系
✓ 动态规划问题（DP）
```

---

## 3. 递推的基本思想

### 递推三步法

```
Step 1: 确定初始条件（边界条件）
        "最简单的情况是什么？答案是什么？"

Step 2: 建立递推关系
        "如何用前面的值计算后面的值？"

Step 3: 从小到大逐步计算
        "从初始条件开始，按递推关系逐步计算到目标"
```

### 示例：爬楼梯问题

**问题**：每次可以爬 1 或 2 个台阶，爬到 n 阶有多少种方法？

```
Step 1: 确定初始条件
        f(1) = 1  (一种方法：1)
        f(2) = 2  (两种方法：1+1 或 2)

Step 2: 建立递推关系
        想要到达第 n 阶，可以从第 n-1 阶爬 1 阶，
        或者从第 n-2 阶爬 2 阶。
        因此：f(n) = f(n-1) + f(n-2)

Step 3: 从小到大逐步计算
        f(3) = f(2) + f(1) = 2 + 1 = 3
        f(4) = f(3) + f(2) = 3 + 2 = 5
        f(5) = f(4) + f(3) = 5 + 3 = 8
        ...
```

```cpp
int climbStairs(int n) {
    if (n <= 2) return n;

    int prev2 = 1, prev1 = 2;  // f(1), f(2)
    int curr;

    for (int i = 3; i <= n; i++) {
        curr = prev1 + prev2;   // f(i) = f(i-1) + f(i-2)
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

### 递推的本质

```
递推的本质是：已知过去，推导未来

就像多米诺骨牌：
- 第一块倒下（初始条件）
- 每一块都会推倒下一块（递推关系）
- 最终所有骨牌都倒下（得到结果）

关键：
1. 初始条件必须明确
2. 递推关系必须正确
3. 计算顺序必须从前往后
```

---

## 4. 递推的要素

### 要素一：初始条件（边界条件）

```cpp
// 斐波那契数列的初始条件
int prev2 = 0;  // F(0)
int prev1 = 1;  // F(1)

// 阶乘的初始条件
long long result = 1;  // 0! = 1
```

**常见初始条件类型：**
```
- 单一起点：f(0) = 0
- 双重起点：f(0) = 0, f(1) = 1（斐波那契）
- 数组初始化：dp[i] = 1（所有元素初始为1）
- 特殊值：最大值、最小值、无穷大
```

### 要素二：递推关系式

```cpp
// 线性递推：只依赖前一项
curr = prev1 * 2;              // f(n) = 2 * f(n-1)

// 二阶递推：依赖前两项
curr = prev1 + prev2;         // f(n) = f(n-1) + f(n-2)

// 高阶递推：依赖多项
curr = prev1 + prev2 + prev3; // f(n) = f(n-1) + f(n-2) + f(n-3)
```

**递推关系类型：**
```
- 线性递推：f(n) = a * f(n-1) + b
- 多项递推：f(n) = f(n-1) + f(n-2) + ... + f(n-k)
- 带系数：f(n) = a1 * f(n-1) + a2 * f(n-2)
- 带常数：f(n) = 2 * f(n-1) + 1
- 矩阵递推：使用矩阵快速幂优化
```

### 要素三：计算方向与范围

```cpp
// 从小到大计算（正向递推）
for (int i = 2; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2];
}

// 从大到小计算（反向递推，用于节省空间）
for (int i = n; i >= 1; i--) {
    dp[i] = dp[i+1] + 1;
}

// 二维递推
for (int i = 1; i <= m; i++) {
    for (int j = 1; j <= n; j++) {
        dp[i][j] = dp[i-1][j] + dp[i][j-1];
    }
}
```

**计算方向选择原则：**
```
✓ 一维问题：通常从左到右
✓ 二维问题：按行或按列，或对角线
✓ 路径问题：从终点反向推到起点
✓ 空间优化：根据依赖关系确定方向
```

---

## 5. 递推的常见类型

### 5.1 线性递推

每个状态只依赖前一个状态。

```cpp
// 阶乘：n! = (n-1)! * n
long long factorial(int n) {
    long long result = 1;  // 0! = 1
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

// 等差数列：a(n) = a(n-1) + d
int arithmetic(int a1, int d, int n) {
    int result = a1;
    for (int i = 2; i <= n; i++) {
        result += d;
    }
    return result;
}
```

### 5.2 二阶递推

每个状态依赖前两个状态。

```cpp
// 斐波那契：F(n) = F(n-1) + F(n-2)
int fibonacci(int n) {
    if (n <= 1) return n;
    int prev2 = 0, prev1 = 1;
    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}

// 爬楼梯：f(n) = f(n-1) + f(n-2)
int climbStairs(int n) {
    if (n <= 2) return n;
    int prev2 = 1, prev1 = 2;
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

### 5.3 多阶递推

每个状态依赖多个前面的状态。

```cpp
// 三阶斐波那契（Tribonacci）：T(n) = T(n-1) + T(n-2) + T(n-3)
int tribonacci(int n) {
    if (n == 0) return 0;
    if (n <= 2) return 1;

    int prev3 = 0, prev2 = 1, prev1 = 1;
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2 + prev3;
        prev3 = prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

### 5.4 二维递推

状态是二维的，需要两个维度的递推。

```cpp
// 杨辉三角：C(n, k) = C(n-1, k-1) + C(n-1, k)
vector<vector<int>> pascalTriangle(int numRows) {
    vector<vector<int>> result(numRows);

    for (int n = 0; n < numRows; n++) {
        result[n].resize(n + 1);
        result[n][0] = result[n][n] = 1;  // 边界条件

        for (int k = 1; k < n; k++) {
            result[n][k] = result[n-1][k-1] + result[n-1][k];
        }
    }
    return result;
}

// 网格路径：从左上角走到右下角，只能向右或向下
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m, vector<int>(n, 1));

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];  // 从上边或左边来
        }
    }
    return dp[m-1][n-1];
}
```

### 5.5 矩阵递推

用矩阵快速幂加速线性递推。

```cpp
// 斐波那契的矩阵快速幂解法
// [F(n+1)]   [1 1]^n   [F(1)]
// [F(n)  ] = [1 0]   * [F(0)]

struct Matrix {
    long long mat[2][2];
    Matrix() {
        mat[0][0] = mat[0][1] = mat[1][0] = mat[1][1] = 0;
    }
};

Matrix multiply(Matrix a, Matrix b) {
    Matrix c;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            for (int k = 0; k < 2; k++) {
                c.mat[i][j] += a.mat[i][k] * b.mat[k][j];
            }
        }
    }
    return c;
}

Matrix matrixPow(Matrix a, int n) {
    Matrix result;
    result.mat[0][0] = result.mat[1][1] = 1;  // 单位矩阵

    while (n > 0) {
        if (n % 2 == 1) result = multiply(result, a);
        a = multiply(a, a);
        n /= 2;
    }
    return result;
}

long long fibonacci(int n) {
    if (n <= 1) return n;

    Matrix base;
    base.mat[0][0] = base.mat[0][1] = base.mat[1][0] = 1;
    base.mat[1][1] = 0;

    Matrix result = matrixPow(base, n - 1);
    return result.mat[0][0];
}

// 时间复杂度：O(log n)
```

---

## 6. 经典递推问题详解

### 6.1 阶乘（Factorial）

**问题**：计算 n! = n × (n-1) × ... × 1

```cpp
// 递推解法
long long factorial(int n) {
    long long result = 1;  // 0! = 1
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

// 递归解法（对比）
long long factorial_recursive(int n) {
    if (n <= 1) return 1;
    return n * factorial_recursive(n - 1);
}
```

**复杂度分析**：
- 时间复杂度：O(n)
- 空间复杂度：O(1) - 只需要一个变量

---

### 6.2 斐波那契数列（Fibonacci）

**问题**：F(n) = F(n-1) + F(n-2)，F(0)=0, F(1)=1

```cpp
// 方法1：基本递推（推荐）
int fibonacci(int n) {
    if (n <= 1) return n;

    int prev2 = 0, prev1 = 1;
    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
// 时间复杂度：O(n)，空间复杂度：O(1)

// 方法2：数组递推
int fibonacci_array(int n) {
    if (n <= 1) return n;
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
// 时间复杂度：O(n)，空间复杂度：O(n)

// 方法3：矩阵快速幂
long long fibonacci_matrix(int n) {
    if (n <= 1) return n;

    long long a = 0, b = 1, c, d = 1; // [a b; c d]
    long long x1, y1;

    for (int i = 0; i < n - 1; i++) {
        x1 = d * b + c * a;
        y1 = d * (b + a) + c * b;
        a = b;
        b = y1;
        c = y1;
        d = x1 + y1;
    }
    return b;
}
// 时间复杂度：O(log n)
```

**递推表**：
```
n:   0  1  2  3  4  5  6  7   8   9   10
F(n):0  1  1  2  3  5  8  13  21  34  55
```

---

### 6.3 爬楼梯（Climbing Stairs）

**问题**：每次可以爬 1 或 2 个台阶，爬到 n 阶有多少种方法？

```cpp
int climbStairs(int n) {
    if (n <= 2) return n;

    int prev2 = 1, prev1 = 2;  // f(1)=1, f(2)=2
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

**递推关系推导**：
```
要到达第 n 阶：
- 从第 n-1 阶爬 1 阶上来（有 f(n-1) 种方法）
- 从第 n-2 阶爬 2 阶上来（有 f(n-2) 种方法）

因此：f(n) = f(n-1) + f(n-2)
```

**进阶**：每次可以爬 1、2 或 3 个台阶？

```cpp
int climbStairs3(int n) {
    if (n <= 2) return n;
    if (n == 3) return 4;  // 1+1+1, 1+2, 2+1, 3

    int prev3 = 1, prev2 = 2, prev1 = 4;  // f(1), f(2), f(3)
    for (int i = 4; i <= n; i++) {
        int curr = prev1 + prev2 + prev3;  // f(n) = f(n-1) + f(n-2) + f(n-3)
        prev3 = prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

---

### 6.4 杨辉三角（Pascal's Triangle）

**问题**：生成前 n 行的杨辉三角

```cpp
vector<vector<int>> generatePascalTriangle(int numRows) {
    vector<vector<int>> result(numRows);

    for (int n = 0; n < numRows; n++) {
        result[n].resize(n + 1);
        result[n][0] = result[n][n] = 1;  // 每行首尾都是1

        for (int k = 1; k < n; k++) {
            // 递推关系：C(n, k) = C(n-1, k-1) + C(n-1, k)
            result[n][k] = result[n-1][k-1] + result[n-1][k];
        }
    }
    return result;
}
```

**输出示例**：
```
     1
    1 1
   1 2 1
  1 3 3 1
 1 4 6 4 1
```

**递推关系**：
```
C(n, k) = C(n-1, k-1) + C(n-1, k)

解释：从 n 个元素中选 k 个，包含第 n 个元素时
      有 C(n-1, k-1) 种选法
      不包含第 n 个元素时有 C(n-1, k) 种选法
```

---

### 6.5 跳跃游戏（Jump Game）

**问题**：给定一个非负整数数组，初始位置在第一个元素。每个元素代表最大跳跃长度，判断是否能到达最后一个位置。

```cpp
bool canJump(vector<int>& nums) {
    int n = nums.size();
    int maxReach = 0;  // 当前能到达的最远位置

    for (int i = 0; i < n; i++) {
        if (i > maxReach) return false;  // 无法到达当前位置
        maxReach = max(maxReach, i + nums[i]);  // 更新最远位置
        if (maxReach >= n - 1) return true;  // 能到达终点
    }
    return true;
}
```

**递推思想**：
```
maxReach[i] = max(maxReach[i-1], i + nums[i])

如果当前位置 i > maxReach[i-1]，说明无法到达 i
```

---

### 6.6 打家劫舍（House Robber）

**问题**：一排房子，每个房子有一定金额，不能偷相邻的房子，求最大金额。

```cpp
int rob(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    if (n == 2) return max(nums[0], nums[1]);

    int prev2 = nums[0];                    // 只有一个房子
    int prev1 = max(nums[0], nums[1]);      // 有两个房子

    for (int i = 2; i < n; i++) {
        // 递推：偷当前房子 = 不偷前一个 + 当前值
        //      不偷当前房子 = 前一个的结果
        int curr = max(prev1, prev2 + nums[i]);
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

**递推关系**：
```
dp[i] = max(dp[i-1], dp[i-2] + nums[i])

dp[i]：前 i 个房子的最大金额
dp[i-1]：不偷第 i 个房子
dp[i-2] + nums[i]：偷第 i 个房子（不能偷 i-1）
```

---

### 6.7 最长递增子序列（LIS）

**问题**：给定数组，求最长严格递增子序列的长度。

```cpp
// O(n²) 解法
int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;

    vector<int> dp(n, 1);  // 每个位置至少长度为1
    int maxLen = 1;

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        maxLen = max(maxLen, dp[i]);
    }
    return maxLen;
}
```

**递推关系**：
```
dp[i] = max(dp[j] + 1) for all j < i and nums[j] < nums[i]

dp[i]：以 nums[i] 结尾的最长递增子序列长度
```

---

### 6.8 零钱兑换（Coin Change）

**问题**：给定不同面额的硬币和总金额，计算可以凑成总金额的最少硬币数。

```cpp
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, amount + 1);  // 初始化为最大值
    dp[0] = 0;  // 金额0需要0个硬币

    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }

    return dp[amount] > amount ? -1 : dp[amount];
}
```

**递推关系**：
```
dp[i] = min(dp[i - coin] + 1) for all coin in coins

dp[i]：凑成金额 i 所需的最少硬币数
dp[i - coin]：凑成金额 i-coin 所需的最少硬币数
```

---

### 6.9 不同路径（Unique Paths）

**问题**：从 m×n 网格的左上角走到右下角，只能向右或向下，有多少种不同路径？

```cpp
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m, vector<int>(n, 1));

    // 边界条件：第一行和第一列都只有一种路径
    // 已经初始化为1

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}

// 空间优化版本：O(n)
int uniquePaths_optimized(int m, int n) {
    vector<int> dp(n, 1);

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j-1];  // dp[j] 保存上方值，dp[j-1] 是左方值
        }
    }
    return dp[n-1];
}
```

**递推关系**：
```
dp[i][j] = dp[i-1][j] + dp[i][j-1]

从上方来：dp[i-1][j]
从左方来：dp[i][j-1]
```

---

### 6.10 乘积最大子数组（Maximum Product Subarray）

**问题**：找出数组中乘积最大的连续子数组。

```cpp
int maxProduct(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;

    int maxProd = nums[0];
    int minProd = nums[0];  // 也要跟踪最小值（负数×负数=正数）
    int result = nums[0];

    for (int i = 1; i < n; i++) {
        // 如果当前数是负数，最大和最小会互换
        if (nums[i] < 0) {
            swap(maxProd, minProd);
        }

        maxProd = max(nums[i], maxProd * nums[i]);
        minProd = min(nums[i], minProd * nums[i]);

        result = max(result, maxProd);
    }
    return result;
}
```

**递推关系**：
```
maxProd[i] = max(nums[i], maxProd[i-1] * nums[i], minProd[i-1] * nums[i])
minProd[i] = min(nums[i], maxProd[i-1] * nums[i], minProd[i-1] * nums[i])

需要同时跟踪最大和最小，因为负数可能变成最大
```

---

### 6.11 整数拆分（Integer Break）

**问题**：给定正整数 n，将其拆分为至少两个正整数的和，使这些整数的乘积最大化。

```cpp
int integerBreak(int n) {
    if (n <= 3) return n - 1;  // 特殊情况：2→1, 3→2

    vector<int> dp(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;

    for (int i = 4; i <= n; i++) {
        dp[i] = 0;
        for (int j = 1; j <= i / 2; j++) {
            dp[i] = max(dp[i], dp[j] * dp[i - j]);
        }
    }
    return dp[n];
}

// 数学优化：尽可能多地拆分为3
int integerBreak_math(int n) {
    if (n <= 3) return n - 1;
    int product = 1;
    while (n > 4) {
        product *= 3;
        n -= 3;
    }
    product *= n;
    return product;
}
```

---

### 6.12 最长公共子序列（LCS）

**问题**：给定两个字符串，求最长公共子序列的长度。

```cpp
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.length(), n = text2.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i-1] == text2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][n];
}
```

**递推关系**：
```
如果 text1[i-1] == text2[j-1]：
    dp[i][j] = dp[i-1][j-1] + 1
否则：
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

---

### 6.13 编辑距离（Edit Distance）

**问题**：将 word1 转换为 word2 所需的最少操作数（插入、删除、替换）。

```cpp
int minDistance(string word1, string word2) {
    int m = word1.length(), n = word2.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // 边界条件
    for (int i = 0; i <= m; i++) dp[i][0] = i;  // 删除所有字符
    for (int j = 0; j <= n; j++) dp[0][j] = j;  // 插入所有字符

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i-1] == word2[j-1]) {
                dp[i][j] = dp[i-1][j-1];  // 字符相同，无需操作
            } else {
                dp[i][j] = min({
                    dp[i-1][j] + 1,      // 删除
                    dp[i][j-1] + 1,      // 插入
                    dp[i-1][j-1] + 1     // 替换
                });
            }
        }
    }
    return dp[m][n];
}
```

---

## 7. 递推优化技巧

### 7.1 空间优化

**原则**：如果递推只依赖前几个状态，可以用滚动变量代替数组。

```cpp
// 未优化：O(n) 空间
int fibonacci(int n) {
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}

// 优化后：O(1) 空间
int fibonacci_optimized(int n) {
    if (n <= 1) return n;
    int prev2 = 0, prev1 = 1;
    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

### 7.2 矩阵快速幂

**适用场景**：线性递推，且 n 非常大（如 n > 10^6）

```cpp
// 斐波那契的 O(log n) 解法
long long fib(long long n) {
    if (n <= 1) return n;

    vector<vector<long long>> base = {{1, 1}, {1, 0}};
    vector<vector<long long>> result = {{1, 0}, {0, 1}};  // 单位矩阵

    // 矩阵快速幂
    while (n > 0) {
        if (n % 2 == 1) {
            result = matrixMultiply(result, base);
        }
        base = matrixMultiply(base, base);
        n /= 2;
    }

    return result[0][1];
}
```

### 7.3 前缀和优化

**适用场景**：频繁查询区间和

```cpp
// 预处理前缀和
vector<int> prefixSum(n + 1, 0);
for (int i = 0; i < n; i++) {
    prefixSum[i + 1] = prefixSum[i] + arr[i];
}

// O(1) 查询区间 [l, r] 的和
int sum = prefixSum[r + 1] - prefixSum[l];
```

### 7.4 单调队列/栈优化

**适用场景**：滑动窗口最大值、单调递增/递减序列

```cpp
// 滑动窗口最大值
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;  // 存储索引，保持递减
    vector<int> result;

    for (int i = 0; i < nums.size(); i++) {
        // 移出窗口外的元素
        if (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }

        // 保持递减顺序
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }

        dq.push_back(i);

        // 形成窗口后记录结果
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}
```

---

## 8. 递推的应用场景

### 8.1 数列计算

```
- 斐波那契数列
- 阶乘
- 幂运算（快速幂）
- 等差/等比数列
- 卡特兰数
- 斯特林数
```

### 8.2 组合数学

```
- 排列组合
- 杨辉三角
- 路径计数
- 括号匹配
- 出栈序列
```

### 8.3 动态规划

```
- 线性 DP：最长递增子序列
- 区间 DP：矩阵链乘法
- 背包问题：0/1 背包、完全背包
- 序列 DP：LCS、编辑距离
- 状态压缩 DP：位运算优化
```

### 8.4 图论

```
- 最短路径：Bellman-Ford
- 最小生成树：Prim
- 网络流：Ford-Fulkerson
```

### 8.5 实际问题

```
- 金融计算：复利、年金
- 人口预测：人口增长模型
- 传染病传播：SIR 模型
- 排队论：队列长度预测
- 游戏策略：Nim 游戏取石子
```

---

## 9. 递推与动态规划

### 动态规划是递推的升华

```
递推是基础，动态规划是递推的扩展和优化

递推：
- 有明确的递推公式
- 从前向后线性计算
- 通常是一维或二维

动态规划：
- 需要定义状态和状态转移方程
- 可能有多种计算顺序
- 可能有优化策略（空间压缩、状态压缩等）
- 处理更复杂的问题（多阶段决策）
```

### DP 的递推本质

```cpp
// 0/1 背包问题的递推解法
int knapsack(vector<int>& weights, vector<int>& values, int capacity) {
    int n = weights.size();
    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));

    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            // 不选第 i 个物品
            dp[i][w] = dp[i-1][w];

            // 选第 i 个物品（如果能装下）
            if (w >= weights[i-1]) {
                dp[i][w] = max(dp[i][w],
                              dp[i-1][w - weights[i-1]] + values[i-1]);
            }
        }
    }
    return dp[n][capacity];
}

// 递推关系：
// dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i]] + values[i])
```

### 递推 → DP 的转变

```
递推公式 → 状态转移方程
初始条件 → 边界条件
循环计算 → DP 表填充
空间优化 → 滚动数组/状态压缩
```

---

## 10. 常见陷阱与错误

### 陷阱 1：初始条件错误

```cpp
// ❌ 错误：初始条件不完整
int fibonacci(int n) {
    int prev2 = 1, prev1 = 1;  // 应该是 0 和 1
    // ...
}

// ✓ 正确
int fibonacci(int n) {
    if (n <= 1) return n;
    int prev2 = 0, prev1 = 1;
    // ...
}
```

### 陷阱 2：递推关系错误

```cpp
// ❌ 错误：递推关系不正确
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m, vector<int>(n, 1));
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1] + 1;  // 不应该 +1
        }
    }
    return dp[m-1][n-1];
}
```

### 陷阱 3：数组越界

```cpp
// ❌ 危险：可能越界
int solve(vector<int>& arr, int n) {
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // 当 n < 2 时可能越界
    }
}

// ✓ 安全：先检查
int solve(vector<int>& arr, int n) {
    if (n < 2) return 0;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
}
```

### 陷阱 4：整数溢出

```cpp
// ❌ 危险：可能溢出
int fibonacci(int n) {
    int prev2 = 0, prev1 = 1;
    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;  // n > 46 时溢出
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}

// ✓ 安全：使用 long long
long long fibonacci(int n) {
    long long prev2 = 0, prev1 = 1;
    for (int i = 2; i <= n; i++) {
        long long curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

### 陷阱 5：计算顺序错误

```cpp
// ❌ 错误：从后往前计算时覆盖了需要的值
for (int i = n; i >= 1; i--) {
    dp[i] = dp[i] + dp[i+1];  // 依赖后面的值，但已经覆盖
}

// ✓ 正确：从前往后计算
for (int i = 1; i <= n; i++) {
    dp[i] = dp[i] + dp[i-1];  // 依赖前面的值
}
```

---

## 11. 学习路线

```
入门阶段
├── 理解递推思想和递推三要素
├── 01_factorial.cpp - 阶乘计算
├── 02_fibonacci.cpp - 斐波那契数列
└── 03_climbing_stairs.cpp - 爬楼梯问题

基础阶段
├── 04_pascal_triangle.cpp - 杨辉三角
├── 05_unique_paths.cpp - 网格路径
├── 06_robbery.cpp - 打家劫舍
└── 练习：等差/等比数列、幂运算

进阶阶段
├── 07_lis.cpp - 最长递增子序列
├── 08_lcs.cpp - 最长公共子序列
├── 09_coin_change.cpp - 零钱兑换
└── 10_edit_distance.cpp - 编辑距离

高级阶段
├── 11_matrix_fast_power.cpp - 矩阵快速幂
├── 12_knapsack.cpp - 背包问题
├── 13_optimization.cpp - 空间优化技巧
└── 练习：复杂 DP 问题
```

---

## 12. 递推问题求解模板

### 一维递推模板

```cpp
/*
 * 递推问题求解模板（一维）
 */
int solveOneDimensional(int n) {
    // Step 1: 确定初始条件
    if (n <= 1) return n;

    // Step 2: 初始化
    int prev2 = /* 第0项 */;
    int prev1 = /* 第1项 */;
    int curr;

    // Step 3: 递推计算
    for (int i = 2; i <= n; i++) {
        curr = /* 递推关系式 */;  // f(i) = ...
        prev2 = prev1;
        prev1 = curr;
    }

    // Step 4: 返回结果
    return prev1;
}
```

### 二维递推模板

```cpp
/*
 * 递推问题求解模板（二维）
 */
int solveTwoDimensional(int m, int n) {
    // Step 1: 初始化 DP 表
    vector<vector<int>> dp(m, vector<int>(n));

    // Step 2: 边界条件
    for (int i = 0; i < m; i++) dp[i][0] = /* 边界值 */;
    for (int j = 0; j < n; j++) dp[0][j] = /* 边界值 */;

    // Step 3: 递推计算
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = /* 递推关系式 */;
        }
    }

    // Step 4: 返回结果
    return dp[m-1][n-1];
}
```

---

## 13. 实战练习题

### 基础题（必做）
1. [ ] 阶乘计算
2. [ ] 斐波那契数列（基本递推）
3. [ ] 爬楼梯问题
4. [ ] 等差/等比数列求和

### 中等题
5. [ ] 杨辉三角
6. [ ] 网格不同路径
7. [ ] 打家劫舍
8. [ ] 跳跃游戏
9. [ ] 最长递增子序列（O(n²)）
10. [ ] 零钱兑换

### 困难题
11. [ ] 最长公共子序列
12. [ ] 编辑距离
13. [ ] 乘积最大子数组
14. [ ] 整数拆分
15. [ ] 0/1 背包问题

### 挑战题
16. [ ] 矩阵快速幂求斐波那契（O(log n)）
17. [ ] 最长递增子序列（O(n log n)）
18. [ ] 完全背包问题
19. [ ] 多重背包问题
20. [ ] 区间 DP：矩阵链乘法

---

## 14. 总结

### 递推的核心思想

```
递推 = 初始条件 + 递推关系 + 逐步计算

关键点：
1. 明确初始条件（边界条件）
2. 建立正确的递推关系式
3. 选择合适的计算方向和顺序
4. 注意空间和时间优化
```

### 与递归的区别

```
递归：从大到小，自顶向下
递推：从小到大，自底向上

选择依据：
- 递归：问题天然可分、需要回溯
- 递推：有明确递推公式、需要优化
```

### 递推的价值

```
1. 效率更高：避免函数调用开销
2. 空间更优：可以优化为 O(1)
3. 思想清晰：正向思考更符合直觉
4. DP 基础：动态规划的基础
5. 应用广泛：数列、组合、优化等
```

---

## 15. 扩展阅读

### 相关主题

```
- 递归与递推的关系与转换
- 动态规划的状态设计
- 矩阵快速幂算法
- 组合数学中的递推关系
- 线性递推数列的通项公式
```

### 经典书籍

```
- 《算法导论》- 动态规划章节
- 《具体数学》- 递推关系式
- 《算法竞赛入门经典》- 递推与递归
```

### 在线资源

```
- LeetCode: 动态规划标签题目
- 洛谷: 递推与递归题单
- Codeforces: DP 问题集合
```

---

"递推是一种用已知推导未知的艺术，它告诉我们，只要掌握了规律，就能从简单到复杂，一步步构建出完美的答案。"
