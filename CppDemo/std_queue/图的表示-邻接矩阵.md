# 图的表示 - 邻接矩阵

## 目录

1. [概述](#概述)
2. [什么是邻接矩阵](#什么是邻接矩阵)
3. [邻接矩阵的定义](#邻接矩阵的定义)
4. [实现方式](#实现方式)
5. [基本操作](#基本操作)
6. [优缺点分析](#优缺点分析)
7. [应用场景](#应用场景)
8. [代码示例](#代码示例)
9. [与邻接表的对比](#与邻接表的对比)

---

## 概述

**邻接矩阵**（Adjacency Matrix）是表示图中顶点之间相邻关系的一种矩阵形式。它是图的最直观、最基本的表示方法之一。

### 图的两种主要表示方法

| 表示方法 | 数据结构 | 适用场景 |
|---------|---------|---------|
| **邻接矩阵** | 二维数组 | 稠密图、频繁查询边是否存在 |
| **邻接表** | 链表/数组 | 稀疏图、节省内存 |

---

## 什么是邻接矩阵

### 定义

邻接矩阵是一个 **n × n** 的方阵（n 为顶点数），其中：
- **行**：表示源顶点
- **列**：表示目标顶点
- **矩阵值**：表示两个顶点之间是否存在边

### 可视化示例

```
图结构：
    0 --- 1
    |     |
    |     |
    2 --- 3

邻接矩阵：
    0   1   2   3
0 [ 0   1   1   0 ]
1 [ 1   0   0   1 ]
2 [ 1   0   0   1 ]
3 [ 0   1   1   0 ]
```

---

## 邻接矩阵的定义

### 无向图

对于无向图，邻接矩阵是**对称矩阵**：

```
matrix[i][j] = matrix[j][i] = 1  // 如果顶点 i 和 j 之间有边
matrix[i][j] = matrix[j][i] = 0  // 如果顶点 i 和 j 之间没有边
```

**示例**：
```
无向图：0 - 1 - 2

邻接矩阵：
   0  1  2
0 [0, 1, 0]
1 [1, 0, 1]
2 [0, 1, 0]
```

### 有向图

对于有向图，邻接矩阵**不一定对称**：

```
matrix[i][j] = 1  // 如果存在从 i 指向 j 的边
matrix[i][j] = 0  // 如果不存在从 i 指向 j 的边
```

**示例**：
```
有向图：0 → 1 → 2

邻接矩阵：
   0  1  2
0 [0, 1, 0]
1 [0, 0, 1]
2 [0, 0, 0]
```

### 带权图

对于带权图，矩阵中存储的是边的**权值**：

```
matrix[i][j] = weight(i, j)   // 如果存在边
matrix[i][j] = ∞ 或 0         // 如果不存在边
```

**示例**：
```
带权图：0 --5-- 1 --3-- 2

邻接矩阵：
       0    1    2
0 [   0,   5,   ∞ ]
1 [   5,   0,   3 ]
2 [   ∞,   3,   0 ]
```

---

## 实现方式

### 方式一：使用二维数组

```cpp
#include <vector>

class GraphMatrix {
private:
    int V;                              // 顶点数
    std::vector<std::vector<int>> adj;  // 邻接矩阵

public:
    // 构造函数：初始化 n x n 矩阵，全部为 0
    GraphMatrix(int n) : V(n), adj(n, std::vector<int>(n, 0)) {}

    // 添加边
    void addEdge(int u, int v) {
        adj[u][v] = 1;
        adj[v][u] = 1;  // 无向图需要对称赋值
    }

    // 添加有向边
    void addDirectedEdge(int u, int v) {
        adj[u][v] = 1;  // 有向图只需单向赋值
    }

    // 添加带权边
    void addWeightedEdge(int u, int v, int weight) {
        adj[u][v] = weight;
        adj[v][u] = weight;  // 无向图
    }

    // 检查边是否存在
    bool hasEdge(int u, int v) const {
        return adj[u][v] != 0;
    }

    // 获取边的权值
    int getWeight(int u, int v) const {
        return adj[u][v];
    }
};
```

### 方式二：使用传统数组

```cpp
#include <cstring>

class GraphMatrixArray {
private:
    static const int MAX_V = 100;  // 最大顶点数
    int adj[MAX_V][MAX_V];
    int V;

public:
    GraphMatrixArray(int n) : V(n) {
        // 初始化矩阵为 0
        memset(adj, 0, sizeof(adj));
    }

    void addEdge(int u, int v) {
        adj[u][v] = 1;
        adj[v][u] = 1;
    }
};
```

### 方式三：使用位压缩（稀疏矩阵优化）

```cpp
#include <vector>
#include <bitset>

class GraphBitMatrix {
private:
    int V;
    std::vector<std::bitset<100>> adj;  // 使用 bitset 压缩

public:
    GraphBitMatrix(int n) : V(n), adj(n) {}

    void addEdge(int u, int v) {
        adj[u].set(v);
        adj[v].set(u);
    }

    bool hasEdge(int u, int v) const {
        return adj[u].test(v);
    }
};
```

---

## 基本操作

### 1. 添加边

```cpp
// 无向图
void addEdge(int u, int v) {
    if (u >= 0 && u < V && v >= 0 && v < V) {
        adj[u][v] = 1;
        adj[v][u] = 1;
    }
}

// 有向图
void addDirectedEdge(int u, int v) {
    if (u >= 0 && u < V && v >= 0 && v < V) {
        adj[u][v] = 1;
    }
}
```

### 2. 删除边

```cpp
void removeEdge(int u, int v) {
    if (u >= 0 && u < V && v >= 0 && v < V) {
        adj[u][v] = 0;
        adj[v][u] = 0;  // 无向图
    }
}
```

### 3. 检查边是否存在

```cpp
bool hasEdge(int u, int v) const {
    if (u >= 0 && u < V && v >= 0 && v < V) {
        return adj[u][v] != 0;
    }
    return false;
}

// 时间复杂度：O(1) - 直接访问数组
```

### 4. 获取顶点的所有邻接点

```cpp
std::vector<int> getNeighbors(int u) const {
    std::vector<int> neighbors;
    if (u >= 0 && u < V) {
        for (int v = 0; v < V; ++v) {
            if (adj[u][v] != 0) {
                neighbors.push_back(v);
            }
        }
    }
    return neighbors;
}

// 时间复杂度：O(V) - 需要遍历整个行
```

### 5. 获取顶点的度数

```cpp
// 无向图：计算与顶点相连的边数
int getDegree(int u) const {
    int degree = 0;
    if (u >= 0 && u < V) {
        for (int v = 0; v < V; ++v) {
            if (adj[u][v] != 0) {
                degree++;
            }
        }
    }
    return degree;
}

// 有向图：入度和出度
int getInDegree(int u) const {
    int inDegree = 0;
    for (int i = 0; i < V; ++i) {
        if (adj[i][u] != 0) {
            inDegree++;
        }
    }
    return inDegree;
}

int getOutDegree(int u) const {
    int outDegree = 0;
    for (int v = 0; v < V; ++v) {
        if (adj[u][v] != 0) {
            outDegree++;
        }
    }
    return outDegree;
}
```

---

## 优缺点分析

### 优点

| 优点 | 说明 |
|------|------|
| **O(1) 边查询** | 直接访问 `adj[i][j]` 即可知道边是否存在 |
| **实现简单** | 使用二维数组，直观易懂 |
| **适合稠密图** | 当边数接近 n² 时，空间利用率高 |
| **易于遍历** | 按行或列遍历即可 |
| **支持快速矩阵运算** | 可利用矩阵算法处理图问题 |

### 缺点

| 缺点 | 说明 |
|------|------|
| **空间浪费** | 即使没有边，也要分配 O(V²) 空间 |
| **不适合稀疏图** | 大部分位置都是 0，浪费内存 |
| **获取邻接点慢** | 需要 O(V) 时间扫描整行 |
| **扩展性差** | 添加/删除顶点需要重建矩阵 |

### 空间复杂度

- **邻接矩阵**：O(V²)
- **邻接表**：O(V + E)

对于稀疏图（E << V²），邻接表更节省空间。

### 时间复杂度对比

| 操作 | 邻接矩阵 | 邻接表 |
|------|---------|--------|
| 添加边 | O(1) | O(1) |
| 删除边 | O(1) | O(E) |
| 检查边是否存在 | **O(1)** | O(degree(u)) |
| 获取所有邻接点 | O(V) | O(degree(u)) |
| 遍历所有边 | O(V²) | O(V + E) |

---

## 应用场景

### 1. 稠密图

当图的边数接近 V² 时，邻接矩阵是理想选择：

```cpp
// 完全图：每个顶点都与其他所有顶点相连
class CompleteGraph {
public:
    CompleteGraph(int n) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i != j) {
                    addEdge(i, j);
                }
            }
        }
    }
};
```

### 2. 频繁查询边

需要频繁判断两个顶点之间是否有边：

```cpp
bool areConnected(const GraphMatrix& g, int u, int v) {
    return g.hasEdge(u, v);  // O(1) 查询
}

// 示例：社交网络中判断两人是否是好友
bool isFriend(const GraphMatrix& social, int person1, int person2) {
    return social.hasEdge(person1, person2);
}
```

### 3. 图的矩阵运算

使用矩阵算法处理图问题：

```cpp
// 计算图的传递闭包（Warshall 算法）
void transitiveClosure(std::vector<std::vector<int>>& adj) {
    int V = adj.size();

    for (int k = 0; k < V; ++k) {
        for (int i = 0; i < V; ++i) {
            for (int j = 0; j < V; ++j) {
                adj[i][j] = adj[i][j] || (adj[i][k] && adj[k][j]);
            }
        }
    }
}
```

### 4. 小规模图

顶点数量较小（如 V < 1000）时：

```cpp
// 迷宫问题：网格图
class Maze {
private:
    static const int ROW = 10;
    static const int COL = 10;
    bool adj[ROW * COL][ROW * COL];

public:
    Maze() {
        memset(adj, 0, sizeof(adj));
        // 构建迷宫...
    }
};
```

---

## 代码示例

### 示例 1：基本图操作

```cpp
#include <iostream>
#include <vector>
#include <iomanip>

class Graph {
private:
    int V;
    std::vector<std::vector<int>> adj;

public:
    Graph(int vertices) : V(vertices), adj(vertices, std::vector<int>(vertices, 0)) {}

    // 添加无向边
    void addEdge(int u, int v) {
        adj[u][v] = 1;
        adj[v][u] = 1;
    }

    // 添加有向边
    void addDirectedEdge(int u, int v) {
        adj[u][v] = 1;
    }

    // 打印邻接矩阵
    void printMatrix() {
        std::cout << "邻接矩阵：\n";
        std::cout << "   ";
        for (int i = 0; i < V; ++i) {
            std::cout << std::setw(3) << i;
        }
        std::cout << "\n";

        for (int i = 0; i < V; ++i) {
            std::cout << std::setw(3) << i;
            for (int j = 0; j < V; ++j) {
                std::cout << std::setw(3) << adj[i][j];
            }
            std::cout << "\n";
        }
    }

    // 获取度数
    int getDegree(int u) {
        int degree = 0;
        for (int v = 0; v < V; ++v) {
            if (adj[u][v]) degree++;
        }
        return degree;
    }
};

int main() {
    Graph g(4);

    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);

    g.printMatrix();

    std::cout << "\n顶点 0 的度数: " << g.getDegree(0) << std::endl;

    return 0;
}

// 输出：
// 邻接矩阵：
//      0  1  2  3
//   0  0  1  1  0
//   1  1  0  1  0
//   2  1  1  0  1
//   3  0  0  1  0
//
// 顶点 0 的度数: 2
```

### 示例 2：基于邻接矩阵的 BFS

```cpp
#include <iostream>
#include <vector>
#include <queue>

class GraphBFS {
private:
    int V;
    std::vector<std::vector<int>> adj;

public:
    GraphBFS(int vertices) : V(vertices), adj(vertices, std::vector<int>(vertices, 0)) {}

    void addEdge(int u, int v) {
        adj[u][v] = 1;
        adj[v][u] = 1;
    }

    void BFS(int start) {
        std::vector<bool> visited(V, false);
        std::queue<int> q;

        visited[start] = true;
        q.push(start);

        std::cout << "BFS 从顶点 " << start << " 开始: ";

        while (!q.empty()) {
            int u = q.front();
            q.pop();

            std::cout << u << " ";

            // 遍历所有可能的顶点
            for (int v = 0; v < V; ++v) {
                if (adj[u][v] && !visited[v]) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        std::cout << std::endl;
    }
};

int main() {
    GraphBFS g(6);

    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 5);

    g.BFS(0);  // 输出: BFS 从顶点 0 开始: 0 1 2 3 4 5

    return 0;
}
```

### 示例 3：带权图的最短路径

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

class WeightedGraph {
private:
    int V;
    vector<vector<int>> adj;

public:
    WeightedGraph(int vertices)
        : V(vertices), adj(vertices, vector<int>(vertices, INT_MAX)) {

        for (int i = 0; i < V; ++i) {
            adj[i][i] = 0;  // 自己到自己的距离为 0
        }
    }

    void addEdge(int u, int v, int weight) {
        adj[u][v] = weight;
        adj[v][u] = weight;  // 无向图
    }

    // Dijkstra 算法
    void dijkstra(int start) {
        vector<int> dist(V, INT_MAX);
        vector<bool> visited(V, false);

        dist[start] = 0;

        for (int count = 0; count < V - 1; ++count) {
            // 找到未访问的最小距离顶点
            int u = -1;
            int minDist = INT_MAX;

            for (int i = 0; i < V; ++i) {
                if (!visited[i] && dist[i] < minDist) {
                    minDist = dist[i];
                    u = i;
                }
            }

            if (u == -1) break;
            visited[u] = true;

            // 更新邻接点的距离
            for (int v = 0; v < V; ++v) {
                if (!visited[v] && adj[u][v] != INT_MAX &&
                    dist[u] != INT_MAX && dist[u] + adj[u][v] < dist[v]) {
                    dist[v] = dist[u] + adj[u][v];
                }
            }
        }

        // 打印结果
        cout << "从顶点 " << start << " 的最短距离:\n";
        for (int i = 0; i < V; ++i) {
            cout << "到 " << i << ": "
                 << (dist[i] == INT_MAX ? -1 : dist[i]) << endl;
        }
    }
};

int main() {
    WeightedGraph g(5);

    g.addEdge(0, 1, 4);
    g.addEdge(0, 2, 1);
    g.addEdge(1, 4, 4);
    g.addEdge(2, 1, 2);
    g.addEdge(2, 3, 4);
    g.addEdge(3, 4, 4);

    g.dijkstra(0);

    return 0;
}
```

---

## 与邻接表的对比

### 完整对比表

| 特性 | 邻接矩阵 | 邻接表 |
|------|---------|--------|
| **空间复杂度** | O(V²) | O(V + E) |
| **边查询** | O(1) | O(degree(u)) |
| **获取所有邻接点** | O(V) | O(degree(u)) |
| **添加边** | O(1) | O(1) |
| **删除边** | O(1) | O(E) |
| **适合图类型** | 稠密图 | 稀疏图 |
| **实现复杂度** | 简单 | 中等 |

### 选择建议

**使用邻接矩阵的情况**：
- ✅ 稠密图（E ≈ V²）
- ✅ 需要频繁检查边是否存在
- ✅ 顶点数量较少（V < 10000）
- ✅ 需要使用矩阵运算

**使用邻接表的情况**：
- ✅ 稀疏图（E << V²）
- ✅ 需要节省内存
- ✅ 需要频繁遍历所有邻接点
- ✅ 顶点数量很大

### 稠密图与稀疏图的界限

一般当 **E > V² / 10** 时，认为图是稠密的，使用邻接矩阵更合适。

```cpp
// 判断是否应该使用邻接矩阵
bool shouldUseMatrix(int V, int E) {
    return E > V * V / 10;
}
```

---

## 总结

### 邻接矩阵核心要点

1. **定义**：n × n 矩阵，`adj[i][j]` 表示顶点 i 到 j 的边
2. **优点**：O(1) 边查询、实现简单、适合稠密图
3. **缺点**：O(V²) 空间、不适合稀疏图
4. **适用**：小规模图、稠密图、频繁边查询

### 记忆要点

```
邻接矩阵 = 二维数组
空间复杂度 = O(V²)
边查询 = O(1)
获取邻接点 = O(V)
适合 = 稠密图
不适合 = 稀疏图
```

---

## 参考资料

- [GeeksforGeeks - Graph and its representations](https://www.geeksforgeeks.org/graph-and-its-representations/)
- [C++ Reference - std::vector](https://en.cppreference.com/w/cpp/container/vector)
- [图论基础 - 邻接矩阵与邻接表](https://oi-wiki.org/graph/graph-save/)
