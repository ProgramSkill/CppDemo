# 图的表示 - 邻接表

## 目录

1. [概述](#概述)
2. [什么是邻接表](#什么是邻接表)
3. [邻接表的结构](#邻接表的结构)
4. [实现方式](#实现方式)
5. [基本操作](#基本操作)
6. [优缺点分析](#优缺点分析)
7. [应用场景](#应用场景)
8. [代码示例](#代码示例)
9. [与邻接矩阵的对比](#与邻接矩阵的对比)

---

## 概述

**邻接表**（Adjacency List）是一种常用的图的表示方法，它为每个顶点维护一个链表，链表中存储该顶点的所有邻接点。

### 图的两种主要表示方法

| 表示方法 | 数据结构 | 适用场景 |
|---------|---------|---------|
| **邻接矩阵** | 二维数组 | 稠密图、频繁查询边是否存在 |
| **邻接表** | 链表/数组 | **稀疏图**、**节省内存** |

---

## 什么是邻接表

### 定义

邻接表是一个**数组 + 链表**的组合结构：
- **数组**：存储所有顶点（索引即为顶点编号）
- **链表**：每个顶点对应一个链表，存储其所有邻接点

### 可视化示例

```
图结构：
    0 --- 1
    |     |
    |     |
    2 --- 3

邻接表表示：
0 -> [1, 2]
1 -> [0, 3]
2 -> [0, 3]
3 -> [1, 2]
```

### 与邻接矩阵对比

```
同一个图的两种表示：

邻接矩阵：              邻接表：
   0  1  2  3          0 -> [1, 2]
0 [0, 1, 1, 0]         1 -> [0, 3]
1 [1, 0, 0, 1]         2 -> [0, 3]
2 [1, 0, 0, 1]         3 -> [1, 2]
3 [0, 1, 1, 0]

空间：16 个单元          空间：8 个连接 + 4 个头节点
```

---

## 邻接表的结构

### 基本结构

```
数组索引：  0    1    2    3    4
           ↓    ↓    ↓    ↓    ↓
         [ ]  [ ]  [ ]  [ ]  [ ]   // 顶点数组
          |    |    |    |    |
          ↓    ↓    ↓    ↓    ↓
         [1]  [0]  [1]  [2]  [3]   // 邻接点链表
         [2]  [3]  [4]  [ ]  [ ]
         [ ]  [ ]  [ ]  [ ]  [ ]
```

### 无向图的邻接表

无向图的每条边会在两个顶点的链表中各出现一次：

```
图：0 - 1 - 2

邻接表：
0 -> [1]
1 -> [0, 2]
2 -> [1]

特点：每条边被存储两次
```

### 有向图的邻接表

有向图每条边只在源顶点的链表中出现一次：

```
图：0 → 1 → 2

邻接表：
0 -> [1]
1 -> [2]
2 -> [ ]

特点：每条边只存储一次
```

### 带权图的邻接表

链表中不仅存储邻接点，还存储边的权值：

```
图：0 --5-- 1 --3-- 2

邻接表：
0 -> [(1, 5)]
1 -> [(0, 5), (2, 3)]
2 -> [(1, 3)]

存储方式：pair<neighbor, weight>
```

---

## 实现方式

### 方式一：使用 vector（最常用）

```cpp
#include <vector>

class GraphList {
private:
    int V;  // 顶点数
    std::vector<std::vector<int>> adj;  // 邻接表

public:
    // 构造函数：创建 V 个空链表
    GraphList(int vertices) : V(vertices), adj(vertices) {}

    // 添加边
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);  // 无向图
    }

    // 添加有向边
    void addDirectedEdge(int u, int v) {
        adj[u].push_back(v);
    }

    // 添加带权边
    void addWeightedEdge(int u, int v, int weight) {
        adj[u].push_back(v);  // 需要使用 pair 结构
    }

    // 获取顶点 u 的所有邻接点
    const std::vector<int>& getNeighbors(int u) const {
        return adj[u];
    }

    // 检查边是否存在
    bool hasEdge(int u, int v) const {
        for (int neighbor : adj[u]) {
            if (neighbor == v) return true;
        }
        return false;
    }
};
```

### 方式二：带权图的邻接表

```cpp
#include <vector>
#include <utility>

class WeightedGraphList {
private:
    int V;
    // 存储 {邻接点, 权值}
    std::vector<std::vector<std::pair<int, int>>> adj;

public:
    WeightedGraphList(int vertices) : V(vertices), adj(vertices) {}

    void addEdge(int u, int v, int weight) {
        adj[u].push_back({v, weight});
        adj[v].push_back({u, weight});  // 无向图
    }

    void addDirectedEdge(int u, int v, int weight) {
        adj[u].push_back({v, weight});
    }

    // 获取边权值
    int getWeight(int u, int v) const {
        for (const auto& edge : adj[u]) {
            if (edge.first == v) {
                return edge.second;
            }
        }
        return -1;  // 边不存在
    }
};
```

### 方式三：使用 list（频繁删除场景）

```cpp
#include <list>

class GraphListWithList {
private:
    int V;
    std::vector<std::list<int>> adj;

public:
    GraphListWithList(int vertices) : V(vertices), adj(vertices) {}

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    void removeEdge(int u, int v) {
        adj[u].remove(v);
        adj[v].remove(u);
    }
};
```

### 方式四：自定义链表节点

```cpp
#include <vector>

struct ListNode {
    int vertex;
    int weight;
    ListNode* next;

    ListNode(int v, int w = 0) : vertex(v), weight(w), next(nullptr) {}
};

class CustomGraphList {
private:
    int V;
    std::vector<ListNode*> adj;

public:
    CustomGraphList(int vertices) : V(vertices, nullptr) {
        adj.assign(vertices, nullptr);
    }

    void addEdge(int u, int v, int weight = 0) {
        ListNode* newNode = new ListNode(v, weight);
        newNode->next = adj[u];
        adj[u] = newNode;
    }

    ~CustomGraphList() {
        for (int i = 0; i < V; ++i) {
            ListNode* current = adj[i];
            while (current) {
                ListNode* temp = current;
                current = current->next;
                delete temp;
            }
        }
    }
};
```

---

## 基本操作

### 1. 添加边

```cpp
// 无向图
void addEdge(int u, int v) {
    adj[u].push_back(v);
    adj[v].push_back(u);
}

// 时间复杂度：O(1) - vector 的 push_back 平均 O(1)
```

### 2. 删除边

```cpp
// 方法一：使用 remove（需要 list）
void removeEdge(int u, int v) {
    adj[u].erase(std::remove(adj[u].begin(), adj[u].end(), v), adj[u].end());
    adj[v].erase(std::remove(adj[v].begin(), adj[v].end(), u), adj[v].end());
}

// 方法二：使用 list（更高效）
void removeEdgeWithList(int u, int v) {
    adj[u].remove(v);
    adj[v].remove(u);
}

// 时间复杂度：
// - vector + erase: O(degree(u))
// - list + remove: O(degree(u))
```

### 3. 检查边是否存在

```cpp
bool hasEdge(int u, int v) const {
    for (int neighbor : adj[u]) {
        if (neighbor == v) {
            return true;
        }
    }
    return false;
}

// 时间复杂度：O(degree(u)) - 需要遍历邻接表
```

### 4. 获取所有邻接点

```cpp
const std::vector<int>& getNeighbors(int u) const {
    return adj[u];
}

// 时间复杂度：O(1) - 直接返回引用
// 空间复杂度：O(degree(u)) - 存储邻接点
```

### 5. 获取顶点的度数

```cpp
// 无向图
int getDegree(int u) const {
    return adj[u].size();
}

// 时间复杂度：O(1)

// 有向图
int getInDegree(int u) const {
    int inDegree = 0;
    for (int i = 0; i < V; ++i) {
        for (int neighbor : adj[i]) {
            if (neighbor == u) {
                inDegree++;
            }
        }
    }
    return inDegree;
}

int getOutDegree(int u) const {
    return adj[u].size();
}

// 时间复杂度：
// - getInDegree: O(V + E)
// - getOutDegree: O(1)
```

### 6. 遍历所有边

```cpp
void printAllEdges() const {
    for (int u = 0; u < V; ++u) {
        for (int v : adj[u]) {
            if (u < v) {  // 避免重复打印无向图的边
                std::cout << u << " -- " << v << std::endl;
            }
        }
    }
}

// 时间复杂度：O(V + E)
```

---

## 优缺点分析

### 优点

| 优点 | 说明 |
|------|------|
| **空间效率高** | 只存储实际存在的边，O(V + E) |
| **适合稀疏图** | 当 E << V² 时，远比邻接矩阵节省空间 |
| **遍历邻接点快** | 直接访问链表，O(degree(u)) |
| **扩展性好** | 添加顶点只需在数组末尾追加 |
| **灵活** | 易于添加/删除顶点和边 |

### 缺点

| 缺点 | 说明 |
|------|------|
| **边查询慢** | 需要 O(degree(u)) 时间 |
| **实现稍复杂** | 相比邻接矩阵需要更多代码 |
| **缓存不友好** | 链表结构导致内存不连续 |
| **无向图占用加倍** | 每条边存储两次 |

### 空间复杂度

- **邻接表**：O(V + E)
- **邻接矩阵**：O(V²)

对于稀疏图（E << V²），邻接表节省大量空间。

**示例计算**：
```
V = 10000, E = 10000（稀疏图）

邻接矩阵空间：10000² = 100,000,000
邻接表空间：  10000 + 10000 × 2 = 30,000

节省空间：99.97%
```

### 时间复杂度对比

| 操作 | 邻接表 | 邻接矩阵 |
|------|--------|----------|
| 添加边 | O(1) | O(1) |
| 删除边 | O(E) 或 O(degree) | **O(1)** |
| 检查边是否存在 | O(degree(u)) | **O(1)** |
| 获取所有邻接点 | O(degree(u)) | O(V) |
| 遍历所有边 | **O(V + E)** | O(V²) |

---

## 应用场景

### 1. 稀疏图

大多数实际应用的图都是稀疏的：

```cpp
// 社交网络：每个用户的好友数远小于总用户数
class SocialNetwork {
private:
    GraphList network;

public:
    void addFriendship(int user1, int user2) {
        network.addEdge(user1, user2);
    }

    std::vector<int> getFriends(int user) {
        return network.getNeighbors(user);
    }
};
```

### 2. 大规模图

顶点数量很大（百万级）时：

```cpp
// 网页链接图（PageRank）
class WebGraph {
private:
    int numPages;  // 可能数百万
    std::vector<std::vector<int>> links;

public:
    void addLink(int fromPage, int toPage) {
        links[fromPage].push_back(toPage);
    }
};

// 使用邻接矩阵会需要 10^12 的空间（不可能）
```

### 3. 需要频繁遍历邻接点

```cpp
// BFS/DFS 遍历
void BFS(int start, const GraphList& graph) {
    std::queue<int> q;
    std::vector<bool> visited(graph.getV(), false);

    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        // 邻接表：快速遍历所有邻接点
        for (int v : graph.getNeighbors(u)) {
            if (!visited[v]) {
                visited[v] = true;
                q.push(v);
            }
        }
    }
}
```

### 4. 动态图

频繁添加/删除顶点：

```cpp
class DynamicGraph {
private:
    std::vector<std::vector<int>> adj;

public:
    // 添加新顶点
    int addVertex() {
        adj.emplace_back();  // O(1) 摊销
        return adj.size() - 1;
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
};
```

---

## 代码示例

### 示例 1：基本图操作

```cpp
#include <iostream>
#include <vector>

class Graph {
private:
    int V;
    std::vector<std::vector<int>> adj;

public:
    Graph(int vertices) : V(vertices), adj(vertices) {}

    // 添加无向边
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    // 打印邻接表
    void printList() {
        std::cout << "邻接表：\n";
        for (int u = 0; u < V; ++u) {
            std::cout << u << " -> [";
            for (size_t i = 0; i < adj[u].size(); ++i) {
                std::cout << adj[u][i];
                if (i < adj[u].size() - 1) std::cout << ", ";
            }
            std::cout << "]\n";
        }
    }

    // 获取度数
    int getDegree(int u) {
        return adj[u].size();
    }

    // 获取所有邻接点
    std::vector<int> getNeighbors(int u) {
        return adj[u];
    }
};

int main() {
    Graph g(4);

    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);

    g.printList();

    std::cout << "\n顶点 0 的度数: " << g.getDegree(0) << std::endl;

    std::cout << "顶点 0 的邻接点: ";
    for (int v : g.getNeighbors(0)) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}

// 输出：
// 邻接表：
// 0 -> [1, 2]
// 1 -> [0, 2]
// 2 -> [0, 1, 3]
// 3 -> [2]
//
// 顶点 0 的度数: 2
// 顶点 0 的邻接点: 1 2
```

### 示例 2：基于邻接表的 BFS

```cpp
#include <iostream>
#include <vector>
#include <queue>

class GraphBFS {
private:
    int V;
    std::vector<std::vector<int>> adj;

public:
    GraphBFS(int vertices) : V(vertices), adj(vertices) {}

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    void BFS(int start) {
        std::vector<bool> visited(V, false);
        std::queue<int> q;

        visited[start] = true;
        q.push(start);

        std::cout << "BFS 从顶点 " << start << " 开始: ";

        while (!q.empty()) {
            int u = q.front();
            q.pop();

            std::cout << u << " ";

            // 直接遍历邻接表中的所有邻接点
            for (int v : adj[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        std::cout << std::endl;
    }
};

int main() {
    GraphBFS g(6);

    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 5);

    g.BFS(0);  // 输出: BFS 从顶点 0 开始: 0 1 2 3 4 5

    return 0;
}
```

### 示例 3：带权图的最短路径

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

class WeightedGraph {
private:
    int V;
    vector<vector<pair<int, int>>> adj;  // {邻接点, 权值}

public:
    WeightedGraph(int vertices) : V(vertices), adj(vertices) {}

    void addEdge(int u, int v, int weight) {
        adj[u].push_back({v, weight});
        adj[v].push_back({u, weight});
    }

    void dijkstra(int start) {
        vector<int> dist(V, INT_MAX);
        vector<bool> visited(V, false);

        // 优先队列：{距离, 顶点}
        priority_queue<pair<int, int>,
                       vector<pair<int, int>>,
                       greater<pair<int, int>>> pq;

        dist[start] = 0;
        pq.push({0, start});

        while (!pq.empty()) {
            int u = pq.top().second;
            pq.pop();

            if (visited[u]) continue;
            visited[u] = true;

            // 遍历所有邻接点
            for (const auto& edge : adj[u]) {
                int v = edge.first;
                int weight = edge.second;

                if (!visited[v] && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.push({dist[v], v});
                }
            }
        }

        cout << "从顶点 " << start << " 的最短距离:\n";
        for (int i = 0; i < V; ++i) {
            cout << "到 " << i << ": "
                 << (dist[i] == INT_MAX ? -1 : dist[i]) << endl;
        }
    }
};

int main() {
    WeightedGraph g(5);

    g.addEdge(0, 1, 4);
    g.addEdge(0, 2, 1);
    g.addEdge(1, 4, 4);
    g.addEdge(2, 1, 2);
    g.addEdge(2, 3, 4);
    g.addEdge(3, 4, 4);

    g.dijkstra(0);

    return 0;
}
```

### 示例 4：检测环

```cpp
#include <vector>
#include <unordered_set>

class GraphCycleDetection {
private:
    int V;
    std::vector<std::vector<int>> adj;

    bool dfs(int u, std::unordered_set<int>& visited, int parent) {
        visited.insert(u);

        for (int v : adj[u]) {
            if (v == parent) continue;  // 跳过父节点

            if (visited.find(v) != visited.end()) {
                return true;  // 找到环
            }

            if (dfs(v, visited, u)) {
                return true;
            }
        }

        return false;
    }

public:
    GraphCycleDetection(int vertices) : V(vertices), adj(vertices) {}

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    bool hasCycle() {
        std::unordered_set<int> visited;

        for (int u = 0; u < V; ++u) {
            if (visited.find(u) == visited.end()) {
                if (dfs(u, visited, -1)) {
                    return true;
                }
            }
        }

        return false;
    }
};
```

### 示例 5：拓扑排序（有向图）

```cpp
#include <vector>
#include <queue>

class DirectedGraph {
private:
    int V;
    std::vector<std::vector<int>> adj;

public:
    DirectedGraph(int vertices) : V(vertices), adj(vertices) {}

    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }

    std::vector<int> topologicalSort() {
        std::vector<int> inDegree(V, 0);

        // 计算入度
        for (int u = 0; u < V; ++u) {
            for (int v : adj[u]) {
                inDegree[v]++;
            }
        }

        // 将入度为 0 的节点加入队列
        std::queue<int> q;
        for (int i = 0; i < V; ++i) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }

        std::vector<int> result;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            result.push_back(u);

            for (int v : adj[u]) {
                inDegree[v]--;
                if (inDegree[v] == 0) {
                    q.push(v);
                }
            }
        }

        return result;
    }
};
```

---

## 与邻接矩阵的对比

### 完整对比表

| 特性 | 邻接表 | 邻接矩阵 |
|------|--------|----------|
| **空间复杂度** | **O(V + E)** | O(V²) |
| **边查询** | O(degree(u)) | **O(1)** |
| **获取所有邻接点** | **O(degree(u))** | O(V) |
| **添加边** | O(1) | O(1) |
| **删除边** | O(E) | **O(1)** |
| **遍历所有边** | **O(V + E)** | O(V²) |
| **适合图类型** | **稀疏图** | 稠密图 |
| **实现复杂度** | 中等 | 简单 |
| **缓存友好性** | 较差 | **好** |

### 空间占用对比

```
图：V = 1000, E = 5000（稀疏图）

邻接表：
- 顶点数组：1000
- 边存储：5000 × 2（无向图）
- 总计：11,000 个单元

邻接矩阵：
- 矩阵大小：1000 × 1000
- 总计：1,000,000 个单元

邻接表节省：98.9% 的空间
```

### 性能对比示例

```cpp
// 场景：判断两个顶点是否相连

// 邻接表
bool hasEdge(int u, int v) {
    for (int neighbor : adj[u]) {
        if (neighbor == v) return true;  // 需要遍历
    }
    return false;
}

// 邻接矩阵
bool hasEdge(int u, int v) {
    return adj[u][v] != 0;  // 直接访问
}

// 场景：遍历所有邻接点

// 邻接表
for (int v : adj[u]) {
    process(v);  // 只遍历实际存在的边
}

// 邻接矩阵
for (int v = 0; v < V; ++v) {
    if (adj[u][v]) {  // 需要检查所有顶点
        process(v);
    }
}
```

### 选择建议

**使用邻接表的情况**：
- ✅ 稀疏图（E << V²）
- ✅ 需要节省内存
- ✅ 频繁遍历邻接点
- ✅ 大规模图
- ✅ 动态添加/删除顶点

**使用邻接矩阵的情况**：
- ✅ 稠密图（E ≈ V²）
- ✅ 频繁查询边是否存在
- ✅ 小规模图
- ✅ 需要使用矩阵运算

### 稠密度判断

```cpp
// 判断图是否为稀疏图
bool isSparseGraph(int V, int E) {
    // 稀疏图定义：E < V² / 10
    return E < V * V / 10;
}

// 选择合适的表示方法
bool shouldUseAdjacencyList(int V, int E) {
    return isSparseGraph(V, E);
}
```

---

## 总结

### 邻接表核心要点

1. **定义**：数组 + 链表，为每个顶点存储邻接点列表
2. **优点**：O(V + E) 空间、适合稀疏图、遍历邻接点快
3. **缺点**：边查询慢、无向图占用加倍
4. **适用**：稀疏图、大规模图、频繁遍历

### 记忆要点

```
邻接表 = 数组 + 链表
空间复杂度 = O(V + E)
边查询 = O(degree(u))
获取邻接点 = O(degree(u))
适合 = 稀疏图
节省 = 大量空间
```

### 实际应用建议

- **社交网络**：邻接表（用户数量大，每个用户好友数有限）
- **网页链接**：邻接表（网页数量巨大，每个页面链接有限）
- **小型游戏地图**：邻接矩阵（节点少，需要快速查询）
- **道路网络**：邻接表（路口多，但每个路口连接的街道有限）

---

## 参考资料

- [GeeksforGeeks - Graph and its representations](https://www.geeksforgeeks.org/graph-and-its-representations/)
- [C++ Reference - std::vector](https://en.cppreference.com/w/cpp/container/vector)
- [图论基础 - 邻接表](https://oi-wiki.org/graph/graph-save/)
